# **Effective C++**
---
## C++에 왔으면 C++의 법을 따릅시다
- C++은 *통합언어* 가 아니라 **하위언어의 연합체** 입니다.
  하위 언어에 맞는 말투를 잘 구사하는 것이 중요합니다.
- *매크로* (#define)는 유효범위를 제한할 수 없기 때문에 좋지 않습니다.
  특히 매크로함수는 원하는대로 동작하도록 작성하기 까다롭습니다.
  매크로변수는 **const, enum** 을 매크로함수는 **inline** 을 이용하세요.
- C++의 초기화 규칙은 복잡합니다. 그냥 다 **직접 초기화** 하는게 맘 편합니다.
  클래스의 멤버를 초기화할 때는 **초기화리스트** 를 꼭 사용합시다.
- 비지역 정적객체(ex. 전역객체, 특히 전역객체인 싱글톤, 클래스 안에 static키워드가 붙은 객체)는 사용하지 마세요.
  초기화 순서가 제멋대로일 수 있습니다(다른 번역단위에서 초기화순서가 미정의사항).
  비지역 정적객체는 지역 정적객체로 바꿔서 사용하세요.

## 생성자, 소멸자 및 대입 연산자
- *"기본생성자", "복사생성자", "복사대입연산자", "소멸자"* 는 **자동** 으로 생깁니다.
  자동으로 생긴 함수들이 항상 원하는대로 동작하지는 않습니다.
  원하는대로 동작하도록 직접 잘 작성하거나,
- 아얘 호출되지 못하도록 private으로 선언해서 막으세요.
- *상속될 가능성이 있는 클래스* 는 반드시 **가상소멸자** 를 가져야만 합니다.
  반대로 가능성이 없는 경우는 가상소멸자를 만들지 마세요. 이식성이 사라집니다.
- 생성자 소멸자에서는 동적바인딩이 되지 않습니다. 파생 클래스가 아직 생성아 안됐으니까요.
  따라서 *생성자, 소멸자* 에서는 **가상함수를 호출하지 마세요**
- 대입연산자(operator=)는 \*this의 참조자를 반환하는게 관례입니다.
  그렇게 해야, ```a = b = c;```와 같은 코드가 가능해 집니다.
- 대입연산자(operator=)에서는 **자기대입** 에 대한 예외처리가 필수입니다.
  자신과 상대방을 **swap** 하는 것이 보통 좋은 대책입니다.
- Derived클래스의 복사생성자, 복사대입연산자는 Base클래스의 복사생성자, 복사대입연산자를 꼭 호출해야합니다.
  안그러면 **partial copy** (일부분만 복사됨)가 발생합니다.

## 자원 관리
- 자원관리(포인터, 뮤텍스 등...)는 **자원관리객체, RAII** 를 사용하세요.
  구현하기 귀찮으면 *스마트 포인터* 를 사용하세요.
- RAII는 **복사정책** 을 잘 결정해서 구현해야 합니다.
  소유권이전, 참조카운팅 등의 방식이 있습니다.
  스마트포인터에서는 각각 *auto_ptr, shared_ptr* 로 구현되어있습니다.
- RAII는 관리하는 자원에 접근할 수 있는 ```get()```함수를 제공해주세요.
  스마트포인터에서도 ```get()```으로 구현되어 있습니다.
- ```new```는 ```delete```로 해제하고, ```new []```는 ```delete[]```로 해제해주세요.
  배열타입은 typedef로 선언하지 않는게 좋습니다. 뭘로 해제해야할지 헷갈려요.
- 함수 파라미터에서 ```foo(shared_ptr<T>(new T));```와 같이, 객체생성과 RAII에 집어넣은 동작을 같이 하지 마세요.
  *RAII에 객체를 담는 코드* 는 반드시 **별도의 한 문장** 으로 작성해야합니다.

## 설계 및 선언
- 좋은 인터페이스는 **"제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게"** 만들어야 합니다.
  사용자가 잘못 된 코드를 작성하려하면 빌드가 아얘 안되게끔 만들어어야 합니다.
  새로 작성될 인터페이스는 기존의 인터페이스와 일관성을 유지해주는게 좋습니다.
  되도록 RAII를 사용해서 사용자가 자원관리에 신경쓰지 않도록 해주세요.
- *값에 의한 전달* 보다는 **상수객체 참조자에 의한 전달** 이 좋습니다.
  단 항상 옳은 것은 아닙니다. C++은 하위언어의 연합체라는 것을 기억하세요.
- 대입연산자 정도를 제외하고는 **참조자를 반환하지 마세요**.
  대게 쓰레기값이 반환되거나, 그렇지 않더라도 캡슐화를 해칩니다.
- *멤버변수는 반드시* **private** 에 두고 인터페이스를 통해 접근하게 해야합니다.
  이래야 *내부 로직을 변경하더라도 동일한 인터페이스를 유지* 할 수 있습니다.
  protected는 절대로 보호받는 상태가 아닙니다.
  protected여도 상속만 받으면 접근할 수 있으니까요.
- 유틸리티 함수는 멤버 함수가 아니라, 비멤버 비프렌드 함수로 만듭시다.
  이는 캡슐화 정도를 높이고, 패키징 유연성을 올리며, 기능 확장성을 늘립니다.
- 어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해줄 필요가 있다면(특히 this가 가리키는 객체가 변환 되어야 할 경우에), 그 함수는 비멤버이어야 합니다.

## 구현
- 변수의 정의는 최대한 늦게, **사용하기 직전** 에 해주세요.
  사용하지도 않는데 생성/소멸이 일어나면 아까우니까요.
- **C스타일 캐스팅은 하지마세요**.
  컴파일러가 도와줄 수 도 없을 뿐더러, 눈에 잘 보이지도 않습니다.
- 어떤 객체 *내부 요소에 대한 핸들을 반환하는 것은 되도록 피하세요**.
  잘못하면 무효참조핸들이 나오고, 캡슐화에 좋지도 않습니다.
- 예외 안전성 보장은 기본적인 보장, 강력한 보장, 예외금지 보장이 있습니다.
  적어도 *기본적인 보장은 해주는게 좋습니다*.
  강력한 보장은 별로 실용적이지 않아서 많이는 안씁니다.
- *inline 함수* 는 **작고 자주 호출되는** 함수에만 사용합시다.
  아무데나 막 쓰면 목적코드 크기만 커져요.
- **컴파일 의존성** 을 낮추는데는 **Pimpl 이디엄** 을 쓰세요.
  느려지지 않을까 걱정되면 배포 직전에 클래스를 합치면 됩니다.

## 상속, 그리고 객체지향
- 아직 정리를 못했네...
