# 8장 일반적인 프로그래밍 원칙들
---
## 45: 지역 변수의 유효범위를 최소화하라
- 지역변수의 유효범위를 최소화하면 가독성과 유지보수성이 좋아지고, 오류 발생 가능성도 줄어든다.
- 지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.
- 지역 변수를 너무 빨리 선언하면 유효범위가 너무 앞쪽으로 확장될 뿐 아니라, 너무 뒤쪽으로도 확장된다.
- 거의 모든 지역 변수 선언에는 초기값이 포함되어야 한다.
- 초기화 하기에 정보가 불충분하다면, 그때까지는 선언을 미뤄야한다.
    - try-catch 블록이 사용될 때는 예외적 상황이 생길 수도 있다.
- for문이나 for-each문의 경우, 순환문 변수라는 것을 선언할 수 있는데, 그 유효 범위는 선언된 지역(즉, for다음에 오는 순환문 괄호와 순환문 몸체\{\} 내부의 코드) 안으로 제한된다.
- '복사해서 붙여넣기' 버그가 for문이나 for-each문에서도 생길 수 있을까? 컴파일 조차 되지 않을 것이므로 어려울 것이다.
- for문을 사용할 때는 순환문마다 다른 이름의 변수를 이용할 필요가 없기 때문에, 복사해서 붙여넣기 버그가 발생할 가능성은 더욱 줄어든다.
- 각각의 for 문은 서로 의존성이 없으므로, 같은 변수명을 거듭 사용해도 상관없다.
- ```for (int i = 0; n = expensiveComputation(); i < n; i++)```
    - 두 번째 변수 n은 i값의 범위를 제한하는 용도로 쓰이고 있는데, 그 값을 계산하는 비용이 꽤 크다.
- 메서드의 크기를 줄이고 특정한 기능에 집중하라는 것이다.
- 한 가지 기능을 수행하는 데 필요한 지역 변수의 유효범위가 다른 기능까지 확장되는 문제가 생긴다.
- 각 기능을 나눠서 별도 메서드로 구현해야 한다.

---

## 46: for문보다는 for-each문을 사용하라
- for-each문은 성가신 코드를 제거하고 반복자나 첨자 변수를 완전히 제거해서 오류 가능성을 없앤다.
- for-each문에서 : 기호는 "안에 있는(in)"이라고 읽는다.
- ```for (Element e : elements)```
- "elements 안에 있는 e 각각에 대해서(for)"라고 읽으면 된다.
- 어떤 상황에서는 일반 for문보다 나은 성능을 보이기도 한다. 배열 첨자가 이동할 수 있는 한계를 딱 한번만 계산하기 때문.
- for-each문으로는 컬렉션과 배열뿐 아니라 Iterable 인터페이스를 구현하는 어떤 객체도 순회할 수 있다.
- 원소들의 그룹을 나타내는 자료형을 작성할 때는, Iterable은 구현하도록 하라.
- for-each문은 전통적인 for문에 비해 명료하고 버그 발생 가능성도 적으며, 성능도 for문에 뒤지지 않는다.
- 불행히도 아래의 세 경우에 대해서는 for-each문을 적용할 수 없다.
    - 필터링
        - 반복자를 명시적으로 사용해야 한다.
    - 변환
        - 원소의 값을 수정하기 위해서 리스트 반복자나 배열 첨자가 필요하다.
    - 병렬순회
        - 여러 컬렉션을 병렬적으로 순회해야하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구혀해야한다.
        - 반복자나 첨자 변수를 명시적으로 제어할 필요가 있다.

---

## 47: 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라
- 표준 라이브러리를 사용하면 그 라이브러리를 개발한 전문가의 지식뿐만 아니라 여러분보다 먼저 그 라이브러리를 사용한 사람들의 경험을 활용할 수 있다.
- 실제로 하려는 일과 큰 관련성도 없는 문제에 대한 해결방법을 임의로 구현하느라 시간을 낭비하지 않아도 된다.
- 별다른 노력을 하지 않아도 그 성능이 점차로 개선된다는 것이다.
- 시간이 흐르면서 라이브러리에는 새로운 기능이 추가된다.
- 표준 라이브러리를 사용하면 주류 개발자들과 같은 코드를 만들게 된다. 가독성이 높고 유지보수가 쉬우며 다른 개발자들이 재사용하기도 좋다.
- 중요한 새 릴리스가 나올 때마다 많은 기능이 새로 추가되는데, 그때마다 어떤 것들이 추가되었는지를 알아두는 것이 좋다.
    - 자바 프로그래머라면 java.lang.java.util 안에 있는 내용은 잘 알고 있어야 하며, java.io의 내용도 어느정도 알고 있어야 한다.
    - java.util 패키지에 컬렉션 프레임워크
    - java.util 패기지에 병행성 관련 프레임워크
- 바퀴를 다시 발명하지 마라.
- 직접 만든 코드보다는 라이브러리에 있는 코드가 더 낫고, 점차 개선될 가능성도 높다.

---

## 48: 정확한 답이 필요하다면 float와 double은 피하라
- 정확한 결과를 제공하지는 않기 때문에 정학한 결과가 필요한 곳에는 사용하면 안된다.
- float와 double은 특히 돈과 관계된 계산에는 적합하지 않다.
    - 10의 거듭제곱 수를 정확하게 나타낼 수 없기 때문
- 돈 계산을 할 때는 BigDecimal, int 또는 long을 사용한다는 원칙을 지켜야 한다.
- BigDecimal을 쓰는 방법에는 두가지 문제가 있다.
    - 기본 산술연산 자료형보다 사용이 불편하며 느리다.
        - BigDecimal의 대안은 int나 long을 사용하는 것이다.
        - 모든 계산을 달러 대신 센트 단위로 하는 것이다
- 정확한 답을 요구하는 문제를 풀 때는 float나 double을 쓰지 말라.
- 사용하기가 좀 불편해도 괜찮으며 성능이 조금 떨어져도 상관없을때는 BigDecimal을 쓰라.
- 성능이 중요하고 소수점 아래 수를 직접 관리해도 상관없으며 계산할 수가 심하게 크지 않을 때는 int나 long을 쓰라.
- 십진수 9개 이하로 표현이 가능할 때는 int를 쓰라.
- 18개 이하로 표현 가능할 때는 long을 쓰라.
- 그 이상일 때는 BigDecimal을 써야 한다.

---

## 49: 객체화된 기본 자료형 대신 기본 자료형을 이용하라
- 기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원을 가진다는 것이다. 값은 같더라도 신원은 다를 수 있다.
- 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 아무 기능도 없는 값, 즉 null이 하나 있다는 것이다.
- 기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적이다.
```
Comparator<Integer> naturalOrder = new Comparator<Integer>(){
    public int compare(Integer first, Integer second) {
        return first < second ? -1 : (first == second ? 0 : 1);
    }
}
```

    - 표현식 ```first < second``` 는 Integer 객체를 기본 자료형 값으로 자동 변환한다.
    - 연산자 ==는 객체 참조를 통해 두 객체의 신원을 비교한다.
        - 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야한다.
        
```
Comparator<Integer> naturalOrder = new Comparator<Integer>() {
    public int compare(Integer first, Integer second) {
        int f = first;
        int s = second;
        return f < s ? -1 : (f == s ? 0 : 1);
    }
}
```
- 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환된다.
- null인 객체 참조를 기본 자료형으로 변환하려 시도하면 NullPointerException이 발생한다.
- 계속해서 객체화와 비객체화를 반복하기 때문에 성능이 느려진다.
- 객체화된 자료형은 언제 사용해야 하나?
    - 컬렉션의 요소, 키, 값으로 사용할 때. 컬렉션에는 기본 자료형을 넣을 수 없으므로 객체화된 자료형을 써야 한다.
    - 제네릭 형인자로는 기본 자료형을 사용할 수 없다.
    - 리플렉션을 통해메서드를 호출할 때도 객체화된 기본 자료형을 사용해야 한다.

---

# 50: 다른 자료형이 적절하다면 문자열 사용은 피하라
- 문자열은 값 자료형을 대신하기에는 부족하다
- 숫자라면 int나 float, BigInteger 같은 수 자료형으로 변환해야 한다.
- 예 아니오를 묻는 질문의 답이라면 boolean으로 변환해야 한다.
- 문자열은 enum 자료형을 대신하기에는 부족하다.
- 문자열은 환합 자료형을 대신하기엔 부족하다.
    - 필드 구분자로 사용한 문자가 필드 안에 들어가버리면 문제가 생긴다.
    - 문자열을 파싱해야 하는데, 느릴뿐더러 멍청하고 오류 발생 가능성도 높은 과정이다.
    - equels, toString, compareTo 메서드 같은 것도 제공할 수 없다.
    - 혼합 자료형을 만들 때는 클래스를 만드는 것이 낫다.
        - 이런 클래스는 보통 private static 멤버클래스로 선언된다.
- 문자열은 권한을 표현하기에 부족하다.
    - ?????

---
