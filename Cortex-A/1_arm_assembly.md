# ARM 어셈블리
---
## CPU
<ALU 그림>
ARM의 CPU는 두 개의 오퍼랜드를 받는 32bit 레지스터 Rs와 OP2가 있습니다. 두 개의 오퍼랜드 레지스터의 값은 32bit ALU에 들어가 결과 값으로 출력되며, 그 값은 32bit 레지스터인 Rd에 담깁니다. 컴퓨터의 모든 연산이 단발적으로 끝나는 것이 아니라, 한 번의 연산과 그 결과의 부수적인 상태에 의존하는 다음 연산의 흐름을 만들기도 합니다. 예컨대, 흔히 N/Z/C/V로 잘 알려져있는 bit값을 다음 연산에 사용하거나, 이를 조건분기에 이용하는 것이 그 예입니다. 어쨌든 이러한 상황정보를 저장하는 레지스터인 CPSR이 추가로 필요합니다. OP2와 ALU 사이에 위치하는 Barrel Shifter는 ARM Core의 특징적인 장치입니다. 이것이 구체적으로 어떤 역할을 하는지는 잠시 잊기로 하고, 이런 것이 있었다는 것만 기억해 둡시다.

## Register File
<레지스터 파일 그림>
다른 모든 CPU가 그러하듯 ARM CPU도 메인 메모리의 값을 오퍼랜드 레지스터로 한번에 가져올 수 없도록 설계되어 있습니다. 따라서 메인 메모리의 값을 오퍼랜드 레지스터로 가져오기 전 한 단계가 더 필요한데, 이 때 메인 메모리의 값을 임시로 받아두는 레지스터들의 묶음을 레지스터 파일이라고 합니다. 메인 메모리의 모든 값은 우선적으로 레지스터 파일 중 한 레지스터에 올라가게 되며, 이를 다시 오퍼랜드 레지스터로 옮겨 ALU가 필요한 처리를 하게 됩니다. 마찬가지로 결과 값 역시 Rd를 거쳐 레지스터 파일 중 한 레지스터에 담기며, 곧바로 메인 메모리에 저장할 수 없습니다.

## Assembly
앞서 설명한 대로 CPU는 메인 메모리에서 오퍼랜드 레지스터로 값을 한 번에 가져올 수 없으며, 중간에 레지스터 파일에 옮겨진 뒤에야 연산이 가능하다고 했습니다. 그렇다면 메인 메모리에서 레지스터 파일로

- LDR <target reg> <loaded value>
  - LDR R0 =0x0001
  - LDR R0 [R1]
