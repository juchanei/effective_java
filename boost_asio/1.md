# Boost.Asio

https://theboostcpplibraries.com/boost.asio
---

## 컨텐츠
- I/O 서비스와 I/O 오브젝트
- 확장성과 멀티스레딩
- 네트워크 프로그래밍
- 코루틴
- 플랫폼특화 I/O 오브젝트

---

이 챕터에서는 Boost.Asio를 소개할 것입니다. 여기서 아시오는 비동기 입출력을 의미합니다. 이 라이브러리는 비동기적인 데이터 처리를 지원합니다. 비동기란 한 오퍼레이션이 수행되는 동안, 이를 수행하는 프로그램이 다음 오퍼레이션을 수행하기 위해 이를 기다리지 않는 것을 의미합니다. 비동기를 지원하는 Boost.Asio는 프로그램에게 오퍼레이션이 끝났음을 알려줍니다. Boost.Asio를 이용해 특정 오퍼레이션이 수행되는 동안 이를 기다리지 않고 다른 오퍼레이션을 수행할 수 있는 장점을 누릴 수 있습니다.

Boost.Thread는 여러 오퍼레이션을 동시에 수행될 수 있도록 하는 또다른 라이브러리입니다. Boost.Thread는 Boost.Asio와 비슷하지만, Boost.Thread가 프로그램 내부 자원에 접근하기 위해 이용되는 것과 달리, Boost.Asio는 프로그램 외부 자원에 접근하기 위해 이용된다는 점에서 차이가 있습니다. 만약 오랜 계산시간이 소요되는 함수가 있다고 합시다. 이 함수는 스레드에서 호출되어 별도의 CPU 코어에서 실행할 수 있습니다. 프로그램의 관점에서 바라볼 때, CPU 코어는 내부 자원이기 때문에 Boost.Thread를 이용해야 합니다. 만약 외부 자원에 접근하길 원한다면 Boost.Asio를 써야합니다.

네트워크 커네션은 외부 자원의 한 예입니다. 데이터를 보내거나 받는 동안 네트워크 카드는 이에대한 오퍼레이션을 수행할 것을 요청받습니다. 네트워크 카드는 보내는 오퍼레이션에서 데이터를 담은 버퍼의 포인터를 받으며, 받는 오퍼레이션에서는 데이터를 담을 버퍼의 포인터를 얻습니다. 네트워크 카드는 프로그램의 관점에서 외부 자원이기 때문에 독립적으로 수행될 수 있습니다. 따라서 데이터를 주고 받는 것을 제외한 다른 오퍼레이션만이 수행시간에 포함됩니다. Boost.Asio는 이러한 기능을 제공함으로서 디바이스롤 보다 효율적이게 사용할 수 있도록 합니다.

네트워크를 통해 데이터를 주고 받는 것은 Boost.Asio의 비동기 오퍼레이션으로 구현되었습니다. 비동기 오퍼레이션을 즉시 리턴되지만 값은 아직 리턴하지 않는 함수로 생각하세요. 결과는 조금 나중에 전달됩니다.

처음 비동기 오퍼레이션이 시작되면, 그 다음엔 비동기 오퍼레이션이 끝났음을 통지받습니다. 시작과 끝이 분리되어 있다는 것은 외부 자원을 블로킹 함수를 호출하지 않고도 접근할 수 있도록 합니다.

---

## I/O 서비스와 I/O 오브젝트

비동기 데이터 프로세싱을 위헤 Boost.Asio를 이용하는 브로그램은 I/O 서비스와 I/O 오브젝트를 기초로 합니다. I/O 서비스는 데이터를 비동기적으로 처리하는 운영체제 인터페이스를 추상화합니다. I/O 오브젝트는 비동기 오퍼레이션을 초기화 합니다. 이 두 컨셉은 태스크를 깔끔하게 분리하기를 요구합니다: I/O 서비스는 운영체제 API를 향하며, I/O 오브젝트는 태스크 개발자의 필요를 향하고 있습니다.

Boost.Asio의 유저로서, 당신은 보통 I/O 서비스를 곧바로 연결하지 않습니다. I/O 서비스는 I/O 서비스 오브젝트에 의해 관리됩니다. 한 I/O 서비스 오브젝트는 I/O 서비스 리스트의 등록자와 같습니다. 모든 I/O 오브젝트는 I/O 서비스를 알고 있으며 I/O 서비스 오브젝트를 통해 I/O 서비스에 접근합니다.

Boost.Asio는 I/O 서비스 오브젝트를 하나의 클래스 boost::asio::io_service로 정의합니다. Boost.Asio에 기반한 모든 프로그램은  boost::asio::io_service 타입의 객체를 사용합니다. 이는 전역 객체일 수도 있습니다.

I/O 서비스 오브젝트를 위한 클래스가 하나만 있는 반면, I/O 오브젝트는 여러 개의 클래스로 존재합니다. 왜냐하면 I/O 오브젝트가 태스크 지향적이기 때문에, 이를 초기하기 위해 각 클래스는 태스크에 의존합니다. 예를 들어, 만약 데이터가 TCP/IP 커넥션을 통해 보내지거나 받아져야 한다면, boost::asio::ip::tcp::socket 타입의 I/O 오브젝트가 사용될 수 있습니다. 만약 데이터가 시리얼포트를 통해 비동기적으로 전송되어야 한다면, boost::asio::serial_port를 이용할 수 있습니댜. 마찬가지로 한 타임 피리어드가 만기되기를 기다려야 한다면, boost::asio::steady_timer를 이용할 수 있습니다.

boost::asio::steady_timer는 알람과 같습니다. 알람벨이 울릴 때 블로킹 함수의 리턴 기다리는 대신에, 당신의 프로그램은 이를 통지받을 것입니다. boost::asio::steady_timer는 그저 타임 피리어드가 만기될 것을 기다리기만 하면 되기 때문에, 다른 외부 자원에 접근할 필요가 없어 보이기 때문입니다. 그러나 실재로는, 운영체제가 타임 피리어드가 만기된 것을 프로그램에게 알리는 기능은 외부 자원입니다. 이는 프로그램이 블로킹 함수를 호출하기 위해 새로운 스레드를 호출하는 것으로부터 자유롭게 되는 것을 의미합니다. boost::asio::steady_timer는 매우 간단한 I/O 오브젝트이기 때문에, Boost.Asio를 소개하는데 사용될 것입니다.
