# 7가지 동시성 모델
---

# Chapter 2 스레드와 잠금장치
스레드와 잠금장치는 원시적이고 어려우며, 새로운 기술과 비교하면 안정성도 떨어지고 위험하다.
하지만 스레드와 잠금장치는 이 책에서 다루는 다른 모델의 근간이 된다.

## 2.1 동작하는 가장 단순한 코드
스레드와 잠금장치는 실제 하드웨어가 동작하는 방식으르 그대로 옮긴 것과 크게 다르지 않다.
따라서 실력이 부족한 프로그래머를 보호해주는 기능이 없다.
이 장에서는 이러한 함정을 피하는 데 도움이 되는 규칙 등을 살펴본다.

## 2.2 상호 배제와 메모리 모델
상호배제는 특정 데이터에 접근하는 스레드가 한 번에 하나만 존재하도록 강제한다.
이는 경쟁조건이나 데드락을 일으킨다.
이 보다 더 중오하고 근본적으로 고민해야 하는 문제가 있는데, 그게 바로 **자바 메모리 모델** 이다.

### 2.2.1 스레드 만들기
동시성 프로그래밍에서 어떤 동작이 일어날 가능ㅅ어이 있으면 그것은 언젠가 일어난다.
아마도 가장 좋지 않은 시점에.

### 2.2.2 첫 번째 잠금장치
두 개의 스레드가 특정 데이터의 값을 읽을 때 (동작이 일어나는 타이밍에 따라 결과가 달라지는) 경쟁조건이 발생할 수 있다.
이를 막기 위한 해법은 해당 데이터에 대한 접근을 동기화 *Synchronize* 하는 것이다.
- mutex
- monitor
- critical section

### 2.2.3 메모리의 미스터리
가끔은 누군가 명령의 수행 순서를 뒤바꿔 놓기도 한다.
- 컴파일러는 코드 실행 순서를 바꿔 **정적 최적화** 를 수행한다.
- JVM은 코드 실행 순서를 바꿔 **동적 최적화** 를 수행한다.
- 코드를 실행하는 하드웨어도 코드의 순서를 바꾸는 것이 가능하다.
따라서 어떤 규칙이 있고, 어디에 기댈 수 있는 지, 어디에 기댈 수 없는지에 대해 알 필요가 있다.
이런 큐칙을 **자바 메모리 모델** (참고 : http://changsuk.me/?p=2050) 이라 한다.

### 2.2.4 메모리 가시성
자바 메모리 모델은 한 스레드가 메모리에 가한 변화가 다른 메모리에 보이는 경우를 정의한다.
읽은 스레드와 쓰는 스레드가 동기화 되지 않으면 그러한 가시성이 보장되지 않는다는 사실이다.
흔히 간과되는 사실은, **값을 변경하는 스레드 뿐만 아니라 읽는 스레도 모두 동기화** ㄴ되어야 한다는 사실이다.
그렇지 않으면 스레드는 오래된 값을 보게 될 수 있다.

### 2.2.5 여러 개의 잠금장치
멀티스레드 환경에서 안정성을 보장하는 방법은 모든 메서드를 동기화 하는 것만 있는 것은 아니다.
이는 몹시 어려울 뿐만 아니라, 스레드를 여러개 사용할 필요가 없을 만큼 효율성이 극도로 떨어진다.
또한 둘 이상의 스레드를 사용하기 시작하면 데드락이 발생할 가능성이 매우 높아진다 (예를 들면 식사하는 철학자).
이러한 데드락을 피하기 위해서는 **잠금장치를 요청할 때 항상 미리 정해진 공통의 순서를 따라 사이클을 만들지 않도록** 하면된다.
하지만 모든 코드가 공통 규칙을 따르기 어려운 커다란 프로그램에서는 이를 지키기 어렵다.

### 2.2.6 외부 메서드의 위험
동기화 된 메서드가 외부의 메서드를 호출하는 경우 문제가 발생할 수 있다.
외부 메서드가 다른 잠금장치를 요구하거나 문제를 일으키는 다른 일을 수행할 수도 있다.
이는 공통의 순서를 따르고 있지 않은 두 개의 잠금장치를 요청하여 데드락을 일으킬 수 있다.
이러한 위험을 피하는 유일한 방법은 **어떤 잠금장치를 보유하고 있는 상태에서는 외부 메서드를 호출하지 않는 것** 이다.
방어적인 복사는 이를 위한 한 가지 방법이다.


## 2.3 내재된 잠금장치를 넘어서
내재된 잠금장치는 편리하지만 다음과 같은 문제가 있다.
- 블로킹 상태에 빠진 스레드를 원상복귀시킬 방법이 없다.
- 잠금장치를 얻기 위해 대기하는 시간을 강제로 중단시킬 수 없다.
- 잠금장치를 얻는 방법이 synchronized 하나뿐이다.
자바 5는 java.util.concurrent를 통해 이러한 문제를 해결한다.
예를 들어, ReentrantLock과 try-finally 구문을 이용하면 스스로 잠금을 풀도록 할 수 있다.

### 2.3.1 가로채기가 가능한 잠금장치
내재된 잠금장치 때문에 스레드에 데드락이 발생하면, 블로킹 상태를 가로챌 수 있는 방법은 JVM을 죽이는 것 말고는 없다.
ReentrantLock의 lockInterruptibly()를 이용하면 Thread.interrupt()가 호출되었을 때 종료됨으로써 이러한 문제를 해결할 수 있다.

### 2.3.2 타임아웃
ReentrantLock의 tryUnlockL()을 이용하면 일정 시간동안 잠금장치를 얻지 못하면 타임아웃을 일으켜 데드락을 방지한다.
하지만 모든 스레드가 동시에 타임아웃을 발생시키면 곧바도 데드락 상태에 빠질 수도 있다.
모든 락의 타임 아웃 시간을 다르게 한다면 이러한 문제를 어느정도 완화시킬 수 있지만, 어쨋든 타임아웃은 그다지 좋은 해법이 아닌 것은 확실하다.

### 2.3.3 협동 잠그기
ReentrantLock은 lock(), unlock()을 제공함으로써 synchronized가 하지 못하는 자유로운 잠금이 가능하다.
그 예로, 하나의 리스트를 여러 스레드가 공유하는 경우, 리스트 전체를 synchronized로 통째로 잠그는 것이 아니라 접근하는 일부 노드만 잠궈 효율을 높일 수 있다.

### 2.3.4 조건 변수
ReentrantLock은 Condition이라는 조건변수를 이용하면 try-finally 구문을 통해 특정 조건에 unlock()을 할 수 있게 하는 것이 가능하다.
Condition의 await()는 해당 조건이 참이 될 때까지 블로킹 되는 작업을 원자적으로 수행한다.
다른 스레드가 Condition의 signal(), signalAll()을 호출하면 await()는 블로킹을 멈추고 잠금장치를 다시 획득한다.
이미 await()가 참을 리턴하는 경우, 실재로 조건이 참인지 확인하기 위해 while 구문을 통해 확인하는 패턴을 이용해야 한다???

### 2.3.5 원자 변수
원자 변수를 이용하면 두 가지 장점을 얻을 수 있다.
- 필요한 경우 잠금장치를 획득해야 한다는 사실을 잊는 것을 방지할 수 있다.
- 잠금장치가 하나도 개입되지 않기 때문에 원자 변수에 대한 동작이 데드락에 걸리는 일도 불가하다.
이를 바탕으로 잠금장치나 블로킹에 기대지 않고 동기화를 구현하는 **논 블로킹** , **락프리 알고리즘** 의 기초를 제공한다.
<br>
volatile 키워드는 해당 변수를 읽거나 쓰는 동작의 순서가 뒤바뀌지 않도록 한다.
그러나 최근의 JVM의 최적화로 잠금장치의 오버헤드가 최소화되었기 때문에, java.util.concurrent.atomic의 클래스를 사용하는 것이 더 낫다.
