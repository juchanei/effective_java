# 7장 메서드
---
## 38: 인자의 유효성을 검사하라
- 메서드의 오류는 가급적 빨리 탐지되어야 한다.
- 메서드 앞부분에서 인자의 유효성을 검사하면 잘못된 인자가 전달되어도 오류를 검출할 수 있다.

### 유효성을 위반하였을 때
- public 메서드
    - **예외** 를 던진다.
    - 발생하는 예외를 javadoc의 @throws 태그를 사용해서 문서화한다.
- public이 아닌 메서드
    - **assertion** 을 이용해 걸러낸다.
    - 패키지 개발자가 메서드 호출이 이루어지는 상황을 통제할 수 있으므로 항상 유효한 인자가 전달될 것으로 생각할 수 있기 때문
    - assertion은 확증 조건이 만족되지 않으면 AssertionError를 낸다.
    - 활성화 되지 않은 assertion은 실행되지 않으므로 비용이 0이다.
    - assertion을 활성화 시키려면 java 인터프리터에 -ea 또는 -enableassertions 옵션을 주어야 한다.

### 예외상황
- 오버헤드가 너무 큰 경우
- 유효성 위반을 걸러내기에 비현실적인 경우
- 계산과정에서 유효성 검사가 자연스럽게 이뤄지는 경우
    - 예를 들면 Collections.sort(List)가 있다. List는 모두 비교가능한 객체여아 한다. 만일 그렇지 않다면 비교 중에 ClassCastException이 발생한다. 따라서 List의 모든 객체가 비교가능한지 Collections.sort()에서 검사할 필요가 없다.
    - 그러나 암묵적인 유효성 검사방법에 지나치게 의존하면, **실패원자성(failure atomicity)** 을 잃게 된다?????
    - 때로는 검사가 실패했을 때 엉뚱한 예외가 던져지는 경우가 있다. 이때는 **예외변환 숙어(exception translation)** 를 사용해 문서에 명시된 예외로 변환해야 한다.

### 유의
- "인자에 예외를 두는 것은 바람직하다"라고 믿어버리면 곤란하다.
- 메서드는 가능하면 일반적으로 적용될 수 있도록 설계해야 한다.
- 메서드는 제약이 적으면 적을수록 좋다.

---

## 39: 필요하다면 방어적 복사본을 만들어라
- 우리가 만드는 클래스의 클라이언트가 불변식(invariant)를 망가뜨리기 위해 최선을 다할 것이라는 가정하에, 방어적으로 프로그래밍 해야한다.
- 클라이언트로부터 받거나(인자) 반환되는 변경 가능한 컴포넌트는 반드시 방어적으로 복사해야 한다.

### 내용
- 생성자로 전달되는 변경 가능 객체는 반드시 방어적으로 복사해야한다.
- 인자의 유효성을 검사하기 전에 방어적 복사본을 만든다. 즉, 유효성 검사는 방어적 복사본에 대해서 시행한다.
    - 방어적 복사본이 만들어지기 까지의 시간은 **취약구간** 이다. 위는 이 구간에서 다른 스레드가 인자를 변경해버리는 일(TICTOU 공격)을 막기 위함이다.
- 생성자에서 는 방어적 복사본을 만들 때 인자가 **계승 가능한 자료형** 일 경우, clone 메서드를 사용해 복사하지 않는다.
    - 악의적인 목적을 가진 객체를 반환하도록 오버라이딩 된 clone 메서드일 수 있기 때문.
    - 이러한 객체는 내부 참조를 private static 리스트에 담아 공격자가 참조할 수 있도록 한다.
    - 일단 생성자에서 계승되지 않은 진짜 객체임을 확인했다면, clone 메서드를 이용해 방어적 복사를 해도 된다.
- 변경 가능 내부 필드를 반환하는 접근자는, 참조가 아닌 방어적 복사본을 반환해야 한다.
    - 길이가 0이 아닌 객체는 항상 변경 가능하다는 사실을 기억하자.

### 교훈
- 객체의 컴포넌트는 가능하면 변경 불가능한 객체를 사용해야 한다.
    - 그래야 방어적 복사본을 만들어 성능에 손해를 보지 않을 수 있다.
- 클라이언트가 객체 내부 상태를 변경하지 않을 것이라는 확신 하에 변경 가능한 객체를 사용한다면
    - 클래스 문서에 메서도 호출자가 인자나 반환값을 변경하면 안된다는 사실을 명시해야한다.

---

## 40: 메서드 시그너처는 신중하게 설계하라
- 메서드 이름은 신중하게 골라야 한다.
    - 표준 작명 관습을 따르는 이름.
    - 이해하기 쉬우면서 패키지 안에 다른 이름과 일관성이 유지되는 이름.
    - 널리 합의된 사항에 부합하는 이름.

- 편의 메서드(convenience method)를 만드는데 너무 열 올리지 마라.
    - 메서드가 너무 많으면 학습, 사용, 테스트, 유지보수 등 모든 측면에서 어렵다.
    - 단축 메서드는 자주 쓰일 때만 추가하라.
- 인자 리스트를 길게 만들지 마라.
    - 인자는 4개 이하가 되도록 애쓰라.
    - 자료형이 같은 인자들이 길게 연결된 인자 리스트는 특히 더욱 위험하다.
        - 실수로 순서를 바꿔 입력해도 문제없이 컴파일 되기 때문.
        - 여러 메서드로 나누거나,
        - 도움 클래스(helper class)를 만들어 인자들을 그룹별로 묶거나,
        - 빌더패턴을 고려하라.
- 인자의 자료형으로는 클래스보다는 인터페이스가 좋다.
    - 아직 만들어지지 않은 하위클래스도 인자로 받을 수 있다.
    - 클래스로 만들 경우, 입력으로 이용할 데이터가 다른 형태의 객체에 보관되어 있는 경우 변환하고 복사하는 비용을 들여야한다.
- 인자의 자료형으로 boolean을 이용하는 것 보다는, 원소가 2개인 enum 자료형을 쓰는게 낫다.
    - 읽기 더 편하다.
    - 다른 옵션을 추가할 때 더욱 편하다.
    - 각 옵셕에 대한 고유 로직을 enum 상수의 메서드로 리패터링해 넣을 수 있다.

---

## 41: 오버로딩할 때는 주의하라
- 오버로딩 된 여러 메서드 중 어떤것이 실행될지는 컴파일 타임에 결정된다.
    - 실행시점의 자료형은 실행 결과에 어떠한 영향도 주지 못한다.
    - 따라서, 오버라이딩 처럼 타입에 따른 다양한 메서드 분기는 불가능하다.

- 오버로딩을 할 때는 혼란스럽지 않게 사용할 수 있도록 주의해야한다.
    - 가능하면 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 같은 API에 포함시키지 않는다.
        - 어렵다면 오버로딩 대신 다른 메서드의 이름을 사용하는 것이 낫다.
        - 만약 오버로딩 할 메서드가 생성자여서 다른 이름을 사용할 수 없다면, 다른 이름의 정적 팩터리 메서드들을 만들어라.
    - 인자의 개수가 같은 오버로딩 메서드를 추가하는 것은 일반적으로 피해야 한다.
    - 아니면, 인자 가운데 적어도 하나가 **확실히 다르도록** 만들어야 한다.
        - 확실히 다르다는 것은, 자료형을 형변환할 수 없는 경우를 의미한다.
        - 자바 1.5부터는 자동객체화와 제네릭이 도입되어, 기본자료형과 참조자료형은 확실히 다른 자료형이 아니게 되었다. 더 주의해야 함.

---

## 42: varargs는 신중히 사용하라
- varargs는 0 이상의 인자를 받는다.

### 주의사항
- 가끔은 1개 이상의 인자를 받아야만 할 필요가 있다.
    - 여기서 varargs를 이용하면 아무 인자도 들어오지 않는 경우가 생겨버린다.
    - 이 때의 문제점은
        - 컴파일 시점이 아니라 런타임에 오류가 발생한다.
        - args의 유효성을 검사하는 코드를 추가해야만 하는, 보기 흉한 코드가 된다.
    - 해결법은
        - ``` int min(int firstArg, int... remainArgs) { /* ... */ } ```
        - 반드시 하나 이상이 되도록 기본 인자를 추가해준다.
- 배열을 마지막 인자로 받는 메서드는, varargs를 마지막 인자로 받는 메서드로, 클라이언트 코드에 영향을 주지 않고 바꿀 수 있다.
    - 하지만 무조건 이를 바꿀 생각은 버리는 것이 좋다.
    - varargs는 정말로 임의이 개수의 인자를 처리할 수 있는 메서드에만 사용하라.
- 성능이 중요한 환경에서는 varargs를 더욱 신중히 사용해야 한다.
    - varargs 메서드를 호출할 때 마다 배열이 만들어지고 초기화 되기 때문.
    - 인자가 0개, 1개, 2개, 3개 ... 인 메서드를 하나씩 오버로딩해서 사용하는 것이 더 나을 수 있다.

---

## 43: null 대신 빈 배열이나 컬렉션을 반환하라
- null을 반환하는 코드는, 항상 null을 반환할 때를 대비한 코드를 만들어야하는 부담이 있다.
- 차라리 null 대신 빈 배열이나 컬렉션을 반환하는 것이 낫다.

### 의심 버리기
- 배열을 반환하는 코드는 배열 생성비용이 들어 더 느리지 않냐라는 의심이 있지만,
    - 해당 메서드가 성능저하의 주범이라는 것이 밝혀지지 않는 한, 그런수준 까지 성능걱정을 할 필요가 없다.
    - 또한, 길이 가 0인 배열은 변경 불가능하므로 재사용 가능하다.

---

## 44: 모든 API 요소에 문서화 주석을
- javadoc은 문서화주석이라 부르는 좀 특별한 주석을 통해서, 소스코드로부터 API 문서를 자동 생성한다.
- 좋은 API문서를 만들려면 API에 포함된 모든 클래스, 인터페이스, 생성자, 메서드 그리고 필드 선언에 문서화 주석을 달아야 한다.
- 자세한 내용 및 사용법은, 오라클의 How to Write Doc Comments[javadoc-quide]을 참고할 것.

---
