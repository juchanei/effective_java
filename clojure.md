# Clojure
## 계기
처음 클로저를 시작하게 된 이유는 폴 부처가 지은 ‘7가지 동시성모델 ‘ 이라는 책 떄문이었습니다.  이 책은 임백준이라는 분이 우리말로 옮겼는데, 그는 평소에 종종 듣던 ‘나는 프로그래머다’ 라는 팟캐스트의 진행자이기도 합니다. ‘백준’ 이라는 이름과 ‘누워서 읽는 알고리즘’ 이라는 책의 저자라는 사실 때문에 유명 알고리즘 풀이 사이트의 운영자와 혼동한적이 있는데, 당시 알고리즘 풀이에 관심이 있던 이유로 그의 책을 처음 읽게 되었습니다. 이후 그가 다른 사람이라는 것을 알게된 이후에도 임백준씨가 쓰거나 우리말로 옮긴 책을 몇권 더 읽었는데, 그 중 하나가 ‘브루스 테이트의 세븐 랭귀지’ 였고 나를 클로저의 세계로 이끈 책 ‘7가지 동시성 모델’과 함께 7가지 시리즈 (영문명으로는 seven ~ in seven weeks 시리즈) 중 하나이기도 한 책입니다. 사실 이 이야기는 이 글을 읽는 사람에겐 클로저를 배우는 것과는 아무 상관 없지만은, 그냥 얘기하고 싶었습니다. 글을 경직되고 장황하게 쓰고 싶지 않아서도 있지만, 새롭게 무언가를 배울 기회가 가끔은 우연히 찾아온다는 것을 말하고 싶기도 해서입니다.

‘7가지 동시성 모델’ 이라는 책에는 락을 이용한 동시성 프로그래밍의 예를 들면서 동시성 프로그래밍의 어려움을 알려주고, 이후에 함수형, 아이덴티티 분리, 액터 모델 등 이전의 방식을 대체할 다른 동시성 패러다임을 소개합니다. 그 중 저는 액터 모델이 궁금해 이 책을 샀지만, 그 보다 앞에 위치한 함수형과 아이덴티티 분리의 모든 예제가 클로저였기 때문에 도중에 셋길로 빠진 케이스입니다. 예제를 따라하다보니 재미가 있었고 좀 더 배우고 싶다는 생각이 들었습니다. 그래서 읽은 책이 캐린 마이어가 쓴 ‘클로저 시작하기’ 입니다. 아직 이 책을 다 읽은 것은 아니지만, 책을 너무 빠르게 읽기도 했고 앞 내용을 탄탄히 하지 않아서 인지 뒷 내용을 더 읽는 것이 지겨워 졌기 때문에 이렇게 정리를 하고자 합니다.

책이 언어의 명세를 자세히 다루는 책도 아니었고, 제가 언어의 철학을 완벽하게 이해한 것도 아니기 때문에 내용은 수박 겉핥기식으로 갈 것 같습니다. 간단하게 언어의 룰을 훑어 보면서 하고싶은 예기도 섞어서 적어보겠습니다.

## 자료형
우리가 프로그래밍을 하는 이유는 흩어져있는 정보를 원하는 형태로 가공하고, 가공된 정보를 바탕으로 새로운 지식(혹은 지식을 얻게끔 도와주는 새로운 정보)를 얻기 위함이 아닐까 싶습니다. 이전까지는 이러한 일을 사람이 손으로 머릿속으로 했었다면, 지금은 실리콘위 전자를 이용한다는점, 이를 매우 많이 추상화한 ‘프로그래밍 언어’를 이용한다는 점에서 차이가 있을 뿐입니다. 어쨌든 사람이나 프로그램이나 어떤 경로를 따르더라도 정보를 얻어야 합니다. 컴퓨터가 사람의 인지능력을 완전히 재현하는 것은 어렵기 때문에 어쩔수 없이 그 중 일부를 모방해 인지하도록 해줘야하는데, 이것이 프로그래밍 언어에서의 자료형입니다(이라고 생각합니다).

C, C++, Java와 같은 언어는 프로그래머가 컴퓨터가 이해할 자료형에 대해 속속들이 잘 알아야 했습니다. 심지어 C 같은 언어는 특정 자료형의 몇번째 비트가 무엇을 의미하는지까지 잘 알아야 제대로된 프로그래밍을 할 수 있다고 할 정도면 말을 다한게 아닌가 싶습니다. 처음 이런 언어들을 배울 때는 이런 것들이 당연하다고 생각했는데, 클로저같이 새로운 언어가 등장하고 심지어 C++과 Java 조차도 새롭게 변하는 모습을 바라보면 당연한 일은 아니었나봅니다.

클로저는 자료형이 프로그래머로 부터 숨겨져있는 언어입니다. 프로그래머는 숨겨져있는 것을 일부러 찾아낼 필요가 없습니다. 일단 코드로 작성하면 컴파일러(혹은 그 비슷한 역할을 할 무언가)가 문맥을 해석해서 적당한 자료형으로 해석합니다. 이런 언어의 특성을 동적타이핑으로, 기능을 타입추론이라고 부르는가 봅니다.

	user=> (type 3.141592)
	java.lang.Double

위 코드는 ‘3.142592’라고 프로그래머가 적은 값이 알아서 Double이라는 자료형으로 인식됐다는 뜻입니다. 사실 굳이 이러한 특성을 이야기하는 것 자체가 자료형이 프로그래머로부터 완벽히 숨겨져있지는 못하다는 것입니다. 어쨌든 프로그래밍을 잘 하려면 이러한 뒷이야기를 속속들이 잘 알아야하기 때문에 이전과 크게 달라진 것이 있나 싶기도 합니다. 그래도 중요한 것은 지금 상태가 아니라 흐름의 방향이 아닌가 싶습니다. 컴퓨터와 사람은 그 본질적인 차이로 인해 시맨틱에 갭이 존재합니다. 그래서 컴퓨터는 사람의 언어를 한방에 알아듣지 못하고, 사람은 컴퓨터의 기계어 명령을 보고 부들부들 합니다. 이러한 시맨팁 갭을 적당히 완충하기 위한 것이 프로그래밍 언어입니다. 과거에는 컴퓨터와 프로그래밍 언어의 갭을 좁혀놓고 프로그래밍 언어와 사람의 갭은 상대적으로 크게 만들어 두었습니다. 앞서 말한 C가 이쯤 해당되지 않을까요? 요즘에는 상황이 역전되려고 하는 듯 합니다. 클로저도 이러한 상황의 부산물 중 하나고요. 점차 컴퓨터의 복잡하고 세세한 부분은 언어가 알아서 처리해줌으로서 프로그래밍 언어와 사람사이의 시맨틱 갭이 좁아지고 있습니다.

위 내용 역시 클로저를 배우는데는 그다지 도움이 되는 말은 아닙니다. 하지만 단순히 언어의 룰을 배우고 외우는 것에 그치는 것이 아니라, 다른 것과는 무엇이 다른지, 왜 다른지에 대해 생각할 필요가 있다고 생각합니다. 중요한 것은 생각입니다. 사람이 해야할 것은 잡다한 세부 구현이 아니라 생각입니다. 이것이 지금까지 말한 것이기도 하고요.

## 진짜 Clojure 자료형
- 정수
- 실수
- 분수
- 문자
- 문자열
- 불리언
- 키워드
- (함수)

책을 읽으면 위 7개의 자료형을 소개합니다. 특이할 만한 것은 분수인데, 말 그대로 분수입니다. `13/17` 이런식으로 적으면 알아서 분수로 인식합니다. 연산 결과도 분수이고, 되도록 약분하여 결과를 간단하게 유지합니다.

또 한가지 특이한 것은 키워드입니다. 처음 시작은 map과 같은 key-value 쌍의 자료구조를 위한 타입이었던 것 같은데, 이 외에도 리스트나 벡터에 들어가기도 하고 스스로 존재하기도 합니다.

마지막에 추가된 8번째 자료형은 함수인데 책에는 함수가 없는데 제가 추가해서 넣었습니다. 사실 클로저와 같은 함수형 언어의 함수는 그 함수가 리턴하는 자료형과 동일한 타입으로 취급됩니다. 함수형 언어의 함수는 순수하기 때문인데, 순수하다는 말을 쉽게 설명하자면 수학에서 말하는 함수를 떠올리면 됩니다. 식을 전개하다 보면 함수에 특정 값을 입력하면 상수로 치환해도 무관했던 것을 기억하시나요? 어쨌든 그런 의미에서 함수를 따로 자료형으로 보지 않는 듯 합니다. 굳이 제가 목록에 추가한 것은, 이 말이 하고 싶어서 였어요.

- 정수
	- `123`
	- java.lang.Long
- 실수
	- `3.141592`
	- java.lang.Double
- 분수
	- `13/17`
	- clojure.lang.Ratio
	- clojure.lang.BigInt (연산 결과가 정수일 때)
- 문자
	- `\a`
	- java.lang.Charactor
- 문자열
	- `“abc”`
	- java.lang.String
- 불리언
	- `true`
	- java.lang.Boolean
- 키워드
	- `:key`
	- clojure.lang.Keyword

다시 한번 적은 목록의 첫 번째 하위목록은 표현법, 두 번째 하위목록은 자료형의 정확한? 이름입니다. 잘 보면 몇개를 제외하면 Java의 타입이라는 것을 볼 수 있는데, 이는 클로저가 JVM 위에서 돌아가는 언어이고 Java와 호완성이 있다는 것을 간접적으로 나타내기도 합니다. 하지만 이에 대해서는 자세히 얘기하지 않으러고 합니다. 과연 클로저의 창시자는 이러한 세부 내용을 프로그래머가 알길 바랬는지 궁금합니다.

## 자료구조
클로저는 4개의 자료구조를 가지고 있습니다.

- 리스트
- 벡터
- 맵
- 셋(집합)
